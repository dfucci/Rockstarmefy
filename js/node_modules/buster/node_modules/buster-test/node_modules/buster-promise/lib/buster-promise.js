var buster = buster || {};

if (typeof module != "undefined") {
    buster = require("buster-core");
}

(function () {
    var states = {
        unresolved: "unresolved",
        resolve: "resolve",
        reject: "reject"
    };

    function notify(listener) {
        if (typeof listener[this.state] == "function") {
            listener[this.state].apply(null, this.resolution);
        }
    }

    function fulfill(how, args) {
        if (this.state != states.unresolved) {
            throw new Error("Promise is already fulfilled");
        }

        this.state = states[how];
        var callbacks = this.callbacks || [];
        this.resolution = Array.prototype.slice.call(args);

        for (var i = 0, l = callbacks.length; i < l; ++i) {
            notify.call(this, callbacks[i]);
        }

        return this;
    }

    var id = 0;

    buster.promise = {
        state: states.unresolved,

        create: function (func) {
            var promise = buster.create(this);
            promise.id = id++;

            if (func) {
                func(this);
            }

            return promise;
        },

        then: function (resolve, reject) {
            var listener = { resolve: resolve, reject: reject };

            if (this.state == states.unresolved) {
                this.callbacks = this.callbacks || [];
                this.callbacks.push(listener);
            } else {
                notify.call(this, listener);
            }

            return this;
        },

        resolve: function () {
            return fulfill.call(this, "resolve", arguments);
        },

        reject: function () {
            return fulfill.call(this, "reject", arguments);
        }
    };

    buster.promise.sequential = function (funcs, opt) {
        opt = opt || {};
        var promise = buster.promise.create();
        var next = function () { runOne(funcs.shift()); }

        if (typeof funcs.slice == "function") {
            funcs = funcs.slice();
        }

        function runOne(func) {
            var resolution;

            if (!func) {
                return promise.resolve();
            }

            try {
                resolution = func.call(opt.thisObj);
            } catch (e) {
                if (opt.error) {
                    opt.error(e);
                } else {
                    promise.reject(e);
                    return;
                }
            }

            if (resolution) {
                resolution.then(next, function () {
                    promise.reject.apply(promise, arguments);
                });
            } else {
                buster.nextTick(next);
            }
        }

        buster.nextTick(next);
        return promise;
    };

    buster.promise.thenable = function (val) {
        if (!val || typeof val.then != "function") {
            var promise = buster.promise.create();
            promise.resolve(val);

            return promise;
        }

        return val;
    };

    buster.promise.all = function () {
        var promise = buster.promise.create();
        var promises = arguments;

        if (arguments.length == 1 &&
            Object.prototype.toString.call(arguments[0]) == "[object Array]") {
            promises = arguments[0];
        }

        var count = promises.length;
        var done = false;
        var data = [];

        function rejecter() {
            if (!done) {
                promise.reject.apply(promise, arguments);
                done = true;
            }
        }

        function resolver(index) {
            return function () {
                if (done) {
                    return;
                }

                data[index] = Array.prototype.slice.call(arguments);
                count -= 1;

                if (count <= 0) {
                    promise.resolve.apply(promise, data);
                    done = true;
                }
            }
        }

        for (var i = 0, l = count; i < l; ++i) {
            promises[i].then(resolver(i), rejecter);
        }

        if (promises.length == 0) {
            promise.resolve();
            done = true;
        }

        return promise;
    };
}());

if (typeof module != "undefined") {
    module.exports = buster.promise;
}