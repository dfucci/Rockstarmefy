if (typeof require != "undefined") {
    var sinon = require("sinon");
    var buster = require("buster-core");
    buster.assertions = require("buster-assertions");
    buster.promise = require("../lib/buster-promise");
    buster.util = require("buster-util");
}

var assert = buster.assertions.assert;
var refute = buster.assertions.refute;

Function.prototype.bind = function (obj) {
    var fn = this;
    var args = Array.prototype.slice.call(arguments, 1);

    return function () {
        return fn.call(obj, args.concat(Array.prototype.slice.call(arguments)));
    };
};

buster.util.testCase("PromiseThenTest", {
    "should return promise for chainable thens": function () {
        var promise = buster.promise.create();
        var result = promise.then(function () {});

        assert.same(promise, result);
    }
});

buster.util.testCase("PromiseResolveTest", {
    setUp: function () {
        this.promise = buster.promise.create();
        this.listeners = [sinon.spy(), sinon.spy()];
    },

    "should call all listeners": function () {
        this.promise.then(this.listeners[0]);
        this.promise.then(this.listeners[1]);

        this.promise.resolve();

        assert(this.listeners[0].called);
        assert(this.listeners[1].called);
    },

    "should call all listeners when one throws": function () {
        this.promise.then(this.listeners[0]);
        this.promise.then(this.listeners[1]);
        var promise = this.promise;

        refute.exception(function () {
            promise.resolve();
        });

        assert(this.listeners[0].called);
        assert(this.listeners[1].called);
    },

    "should throw if already resolved": function () {
        var promise = this.promise;
        promise.resolve();

        assert.exception(function () {
            promise.resolve();
        });
    },

    "should call callback when resolved": function () {
        var listener = sinon.spy();
        this.promise.resolve();
        this.promise.then(listener);

        assert(listener.called);
    }
});

buster.util.testCase("PromiseRejectTest", {
    setUp: function () {
        this.promise = buster.promise.create();
        this.listeners = [sinon.spy(), sinon.spy()];
        this.fail = sinon.stub().throws();
    },

    "should call all listeners": function () {
        this.promise.then(this.fail, this.listeners[0]);
        this.promise.then(this.fail, this.listeners[1]);

        this.promise.reject();

        assert(this.listeners[0].called);
        assert(this.listeners[1].called);
    },

    "should call all listeners when one throws": function () {
        this.promise.then(this.fail, this.listeners[0]);
        this.promise.then(this.fail, this.listeners[1]);
        var promise = this.promise;

        refute.exception(function () {
            promise.reject();
        });

        assert(this.listeners[0].called);
        assert(this.listeners[1].called);
    },

    "should throw if already rejected": function () {
        var promise = this.promise;
        promise.reject();

        assert.exception(function () {
            promise.reject();
        });
    },

    "should call callback when rejected": function () {
        var listener = sinon.spy();
        try { this.promise.reject(); } catch (e) {}
        this.promise.then(this.fail, listener);

        assert(listener.called);
    },

    "should throw if handler throws": function () {
        var promise = this.promise;

        promise.then(function () {
            throw new Error("Oops!");
        });

        assert.exception(function () {
            promise.resolve();
        });
    }
 });

buster.util.testCase("PromiseThenableTest", {
    "should return promise": function () {
        var promise = buster.promise.create();

        assert.same(promise, buster.promise.thenable(promise));
    },

    "should return promise that resolves with value": function () {
        var promise = buster.promise.thenable({ id: 42 });

        promise.then(function (value) {
            assert.equals(value, { id: 42 });
        });
    }
});

buster.util.testCase("PromiseSequentialTest", {
    setUp: function () {
        this.complete = sinon.spy();
        this.promises = [buster.promise.create(), buster.promise.create()];
        this.listeners = [sinon.stub().returns(this.promises[0]),
                          sinon.stub().returns(this.promises[1])];
    },

    "should not call second function if first does not resolve": function () {
        buster.promise.sequential(this.listeners).then(this.complete);

        buster.nextTick(function () {
            assert(this.listeners[0].called);
            refute(this.listeners[1].called);
            refute(this.complete.called);
        }.bind(this));
    },

    "should call second function when first resolves": function () {
        buster.promise.sequential(this.listeners).then(this.complete);

        buster.nextTick(function () {
            this.promises[0].resolve();

            assert(this.listeners[1].called);
            refute(this.complete.called);
        }.bind(this));
    },

    "should call complete callback when all have resolved": function () {
        buster.promise.sequential(this.listeners).then(this.complete);

        buster.nextTick(function () {
            this.promises[0].resolve();
            this.promises[1].resolve();

            assert(this.complete.called);
        }.bind(this));
    },

    "should reject complete callback if a function throws": function (test) {
        this.listeners.push(sinon.stub().throws("TypeError", "Oops"));
        var promise = buster.promise.sequential(this.listeners);

        promise.then(function () {
            assert.fail();
            test.end();
        }, function (e) {
            assert(this.listeners[0].called);
            assert(this.listeners[1].called);
            assert.equals("TypeError", e[0].name);
            assert.equals("Oops", e[0].message);
            test.end();
        }.bind(this));

        this.promises[0].resolve();
        this.promises[1].resolve();
    },

    "should reject complete callback if a promise rejects": function (test) {
        buster.promise.sequential(this.listeners).then(function () {
            assert.fail();
            test.end();
        }, function () {
            assert(this.listeners[0].called);
            refute(this.listeners[1].called);
            test.end();
        }.bind(this));

        this.promises[0].reject();
    },

    "should not reject complete callback if using custom error handler": function (test) {
        var errorHandler = sinon.spy();
        this.listeners.push(sinon.stub().throws("TypeError", "Oops"));
        var promise = buster.promise.sequential(this.listeners, {
            error: errorHandler
        });

        promise.then(function () {
            assert(this.listeners[0].called);
            assert(this.listeners[1].called);
            assert(errorHandler.called);
            test.end();
        }.bind(this), function (e) {
            assert.fail();
            test.end();
        });

        this.promises[0].resolve();
        this.promises[1].resolve();
    }
});

buster.util.testCase("PromiseAllTest", {
    "should return promise": function () {
        var promise = buster.promise.all();

        assert.isObject(promise);
        assert.typeOf(promise.then, "function");
    },

    "should return resolved promise when no input": function () {
        var listener = sinon.spy();

        buster.promise.all().then(listener);

        assert(listener.calledOnce);
    },

    "should resolve returned promise when single input resolves": function () {
        var listener = sinon.spy();
        var promise = buster.promise.create();

        buster.promise.all(promise).then(listener);
        refute(listener.called);

        promise.resolve();
        assert(listener.calledOnce);
    },

    "should resolve returned promise when input arguments resolve": function () {
        var listener = sinon.spy();
        var promises = [buster.promise.create(), buster.promise.create()];

        buster.promise.all(promises[0], promises[1]).then(listener);

        promises[0].resolve();
        refute(listener.called);

        promises[1].resolve();
        assert(listener.calledOnce);
    },

    "should resolve returned promise when inputs in array argument resolve": function () {
        var listener = sinon.spy();
        var promises = [buster.promise.create(), buster.promise.create()];

        buster.promise.all(promises).then(listener);

        promises[0].resolve();
        refute(listener.called);

        promises[1].resolve();
        assert(listener.calledOnce);
    },

    "should resolve returned promise when both inputs resolve in reverse order": function () {
        var listener = sinon.spy();
        var promises = [buster.promise.create(), buster.promise.create()];

        buster.promise.all(promises[0], promises[1]).then(listener);

        promises[1].resolve();
        refute(listener.called);

        promises[0].resolve();
        assert(listener.calledOnce);
    },

    "should reject returned promise if one input rejects": function () {
        var listener = sinon.spy();
        var promises = [buster.promise.create(), buster.promise.create()];

        buster.promise.all(promises[0], promises[1]).then(null, listener);

        promises[1].reject({ message: "Oops" });

        assert(listener.calledOnce);
        assert.equals(listener.args[0][0], { message: "Oops" });
    },

    "should resolve returned promise with array of resolutions": function () {
        var listener = sinon.spy();
        var promises = [buster.promise.create(), buster.promise.create()];

        buster.promise.all(promises[0], promises[1]).then(listener);

        promises[0].resolve(1);
        promises[1].resolve(2);

        assert(listener.calledOnce);
        assert.equals(listener.args[0], [[1], [2]]);
    },

    "should resolve returned promise with ordered array of resolutions": function () {
        var listener = sinon.spy();
        var promises = [buster.promise.create(), buster.promise.create()];

        buster.promise.all(promises[0], promises[1]).then(listener);

        promises[1].resolve(2);
        promises[0].resolve(1);

        assert(listener.calledOnce);
        assert.equals(listener.args[0], [[1], [2]]);
    }
});
