var createServerFor = require("../test-helper").createServerFor;
var buster = require("buster");
var assert = buster.assert;
var refute = buster.refute;
var bClient = require("../../lib/buster-client/client");
var bSession = require("../../lib/buster-client/session");
var http = require("http");
var EventEmitter = require("events").EventEmitter;
var busterResources = require("buster-resources");

buster.testCase("buster.client", {
    "create": {
        "should return client instance": function () {
            var client = bClient.create(9876, "10.0.0.1", "/buster");

            assert(bClient.isPrototypeOf(client));
            assert.equals(client.host, "10.0.0.1");
            assert.equals(client.port, 9876);
            assert.equals(client.path, "/buster");
        },

        "should default path to /": function () {
            var client = bClient.create(1111);

            assert.equals(client.path, "/");
        },

        "should default host to localhost": function () {
            var client = bClient.create(1111);

            assert.equals(client.host, "localhost");
        },

        "should default port to 1111": function () {
            var client = bClient.create();

            assert.equals(client.port, 1111);
        }
    },

    "getCachedResources": {
        setUp: function (done) {
            this.requests = createServerFor(this, done);
            this.client = bClient.create(7777);
        },

        tearDown: function () {
            this.server.close();
        },

        "should GET /resources": function (done) {
            this.client.getCachedResources().then(function () {
                assert.equals(this.requests.length, 1);
                assert.match(this.requests[0], {
                    method: "GET",
                    url: "/resources"
                });

                done();
            }.bind(this));
        },

        "should reject promise if server is unreachable": function (done) {
            var req = new EventEmitter();
            req.end = function () { return req; };
            this.stub(http, "request").returns(req);

            this.client.getCachedResources().then(function () {}, function (err) {
                refute.isNull(err);
                assert.match(err.message, "Oops!");
                done();
            }.bind(this));

            req.emit("error", new Error("Oops!"));
        },

        "should reject if server does not recognize cache requests": function (done) {
            this.responseCode = 404;

            this.client.getCachedResources().then(function () {}, function (err) {
                refute.isNull(err);
                assert.match(err.message, "Is this server (localhost:7777) a buster-capture-server instance?");
                done();
            }.bind(this));
        },

        "should reject if server returns invalid cache data": function (done) {
            this.responseCode = 200;
            this.responseText = "<html>";

            this.client.getCachedResources().then(function () {}, function (err) {
                refute.isNull(err);
                assert.match(err.message, "Is this server (localhost:7777) a buster-capture-server instance?");
                done();
            }.bind(this));
        },

        "should GET contextPath/resources": function (done) {
            this.client.path = "/buster";

            this.client.getCachedResources().then(function () {
                assert.match(this.requests[0], { url: "/buster/resources" });
                done();
            }.bind(this));
        },

        "should yield list of resources and etags": function (done) {
            this.responseText = JSON.stringify({
                "/some/file.js": ["0d44ea2"],
                "/some/stylesheet.css": ["034948f"],
                "/some/text.txt": ["1da82b4"]
            });

            this.client.getCachedResources().then(function (cacheable) {
                assert.equals(cacheable, {
                    "/some/file.js": ["0d44ea2"],
                    "/some/stylesheet.css": ["034948f"],
                    "/some/text.txt": ["1da82b4"]
                });
                done();
            }.bind(this));
        },

        "should yield empty object if no response body": function (done) {
            this.client.getCachedResources().then(function (cacheable) {
                assert.equals(cacheable, {});
                done();
            }.bind(this));
        },

        "should reject promise if malformed response body": function (done) {
            this.responseText = "{";

            this.client.getCachedResources().then(
                function () {}, function (err) {
                    refute.isNull(err);
                    done();
                }.bind(this));
        },

        "should cache result of GET": function (done) {
            this.responseText = JSON.stringify({ "/some/file.js": ["0d44ea2"] });

            this.client.getCachedResources().then(function () {
                this.client.getCachedResources().then(function (resources) {
                    assert.equals(this.requests.length, 1);
                    assert.equals(resources, { "/some/file.js": ["0d44ea2"] });
                    done();
                }.bind(this));
            }.bind(this));
        }
    },

    "useCachedResources": {
        setUp: function () {
            this.client = bClient.create();
            this.promise = buster.promise.create();
            this.stub(this.client, "getCachedResources").returns(this.promise);

            this.readyOnlyResourceSet = function (resourceConf, callback) {
                var self = this;
                var rs = busterResources.createResourceSet({ resources: resourceConf });
                rs.getReadOnly(function (err, resources) {
                    callback.call(self, err, resources);
                });
            };
        },

        "should remove content for cached resource": function (done) {
            this.promise.resolve({ "/file1.js": ["1234"] });

            this.readyOnlyResourceSet({
                "/file1.js": { content: "Hey", etag: "1234" }
            }, function (err, rs) {
                this.client.useCachedResources(rs).then(function (set) {
                    refute.defined(set.resources["/file1.js"].content);
                    done();
                });
            });
        },

        "should use correct etag when several are cached": function (done) {
            this.promise.resolve({ "/file1.js": ["1234", "2345"] });

            this.client.useCachedResources({
                resources: { "/file1.js": { content: "Hey", etag: "2345" } }
            }).then(function (config) {
                assert.equals(config, { resources: { "/file1.js": { etag: "2345" }}});
                done();
            });
        },

        "should not delete content when cached version does not match": function (done) {
            this.promise.resolve({ "/file1.js": ["1234", "2345"] });

            this.client.useCachedResources({
                resources: { "/file1.js": { content: "Hey", etag: "7896" } }
            }).then(function (config) {
                assert.equals(config, {
                    resources: { "/file1.js": { etag: "7896", content: "Hey" } }
                });
                done();
            });
        },

        "should not delete content when no cached version exists": function (done) {
            this.promise.resolve({ "/file1.js": ["1234", "2345"] });

            this.client.useCachedResources({
                resources: { "/file2.js": { content: "Hey", etag: "1234" } }
            }).then(function (config) {
                assert.equals(config, {
                    resources: { "/file2.js": { etag: "1234", content: "Hey" } }
                });
                done();
            });
        },

        "should not delete content when resource is not cacheable": function (done) {
            this.promise.resolve({ "/file1.js": ["1234", "2345"] });

            this.client.useCachedResources({ resources: {
                "/file1.js": { content: "Hey", etag: "1234", cacheable: false }
            }}).then(function (config) {
                assert.equals(config, { resources: {
                    "/file1.js": { etag: "1234", content: "Hey", cacheable: false }
                }});
                done();
            });
        }
    },

    "createSession": {
        setUp: function (done) {
            this.requests = createServerFor(this, done);
            this.client = bClient.create(7777);
            this.session = {};
            this.promise = buster.promise.create();
            this.promise.resolve(this.session);
            this.stub(bSession, "createFromHttpResponse").returns(this.promise);

            this.cache = {};
            var promise = buster.promise.create();
            promise.resolve(this.cache);
            this.stub(bClient, "getCachedResources").returns(promise);
            this.resourceSet = busterResources.createResourceSet();
        },

        tearDown: function () {
            this.server.close();
        },

        "should POST to /sessions": function (done) {
            this.client.createSession({
                resourceSet: this.resourceSet
            }).then(function () {
                assert.equals(this.requests.length, 1);
                assert.match(this.requests[0], {
                    method: "POST",
                    headers: { host: "localhost" },
                    url: "/sessions"
                });

                done();
            }.bind(this));
        },

        "should reject promise if HTTP connection fails": function (done) {
            var req = new EventEmitter();
            req.write = req.end = function () { return req; };
            this.stub(http, "request").returns(req);
            var client = bClient.create(7777, "localhost", "/buster");

            client.createSession({ resourceSet: this.resourceSet }).then(
                function () {}, function (err) {
                    refute.isNull(err);
                    assert.match(err.message, "Oops!");
                    done();
                }.bind(this));

            req.emit("error", new Error("Oops!"));
        },

        "should encode session data in POST body": function (done) {
            var resources = busterResources.createResourceSet();
            resources.addResource("/js/buster.js", {content: "alert('Hello world');"});
            resources.addResource("/css/style.css", {content: "body { color: red; }"});
            resources.appendToLoad("/js/buster.js");
            var options = { resourceSet: resources, joinable: true };

            this.client.createSession(options).then(function () {
                var req = this.requests[0];
                assert.equals(req.headers["content-type"], "application/json");

                assert.match(JSON.parse(req.body), {
                    resourceSet: {
                        resources: {
                            "/js/buster.js": {
                                content: "alert('Hello world');"
                            },
                            "/css/style.css": {
                                content: "body { color: red; }"
                            },
                        },

                        load: ["/js/buster.js"]
                    },
                    joinable: true
                });

                done();
            }.bind(this));
        },

        "should not include cacheable flag in POST body": function (done) {
            var resources = busterResources.createResourceSet();
            resources.addResource("/b.js", { content: "'Hello';", cacheable: false });
            var options = { resourceSet: resources };

            this.client.createSession(options).then(function () {
                var req = this.requests[0];
                assert.equals(req.headers["content-type"], "application/json");
                var resources = JSON.parse(req.body).resourceSet.resources;
                refute.defined(resources["/b.js"].cacheable);
                done();
            }.bind(this));
        },

        "should not send request until session is loaded": function (done) {
            var resources = busterResources.createResourceSet();
            this.stub(resources, "getReadOnly");

            var complete = this.spy(function () {
                assert.equals(this.requests[0].body, '{"resourceSet":{}}');
                done();
            }.bind(this));

            this.client.createSession({ resourceSet: resources }).then(complete);

            process.nextTick(function () {
                refute.called(complete);
                assert.calledOnce(resources.getReadOnly);
                resources.getReadOnly.getCall(0).args[0](null, {});
            });
        },

        "should reject returned promise if session config is bad": function (done) {
            var resources = busterResources.createResourceSet();
            this.stub(resources, "getReadOnly");
            var options = { resourceSet: resources };

            this.client.createSession(options).then(function () {}, function (err) {
                assert.defined(err);
                assert.equals(err.message, "Bad session config: File not found");
                done();
            }.bind(this));

            resources.getReadOnly.getCall(0).args[0](new Error("File not found"));
        },

        "should resolve promise with session object when ready": function (done) {
            var resources = busterResources.createResourceSet();
            var options = { resourceSet: resources };

            this.client.createSession(options).then(function (session) {
                assert.same(session, this.session);
                done();
            }.bind(this));
        },

        "should pass host and port to session.createFromHttpResponse": function (done) {
            var resources = busterResources.createResourceSet();
            var options = { resourceSet: resources };

            this.client.createSession(options).then(function (session) {
                assert.match(bSession.createFromHttpResponse.args[0][1], {
                    host: "localhost",
                    port: 7777
                });

                done();
            });
        },

        "should pass managed to new session": function (done) {
            var resources = busterResources.createResourceSet();
            var options = { resourceSet: resources, managed: true };

            this.client.createSession(options).then(function (session) {
                assert.match(bSession.createFromHttpResponse.args[0][1], {
                    managed: true
                });

                done();
            });
        },

        "should use cached resources": function (done) {
            this.cache["/file1.js"] = ["1234"];

            var resources = busterResources.createResourceSet();
            resources.addResource("/file1.js", { content: "alert();", etag: "1234" });
            resources.addResource("/file2.js", { content: "alert();", etag: "2345" });
            var options = { resourceSet: resources };

            this.client.createSession(options).then(function (session) {
                var sent = JSON.parse(this.requests[0].body).resourceSet.resources;
                refute.defined(sent["/file1.js"].content);
                done();
            }.bind(this));
        },

        "should not use cached resources if configured not to": function (done) {
            this.cache["/file1.js"] = ["1234"];
            this.client.cacheResources = false;

            var resources = busterResources.createResourceSet();
            resources.addResource("/file1.js", { content: "alert();", etag: "1234" });
            resources.addResource("/file2.js", { content: "alert();", etag: "2345" });
            var options = { resourceSet: resources };

            this.client.createSession(options).then(function (session) {
                var sent = JSON.parse(this.requests[0].body).resourceSet.resources;
                assert.defined(sent["/file1.js"].content);
                done();
            }.bind(this));
        }
    }
});
