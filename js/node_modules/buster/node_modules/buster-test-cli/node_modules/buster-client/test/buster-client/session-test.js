var buster = require("buster");
var assert = buster.assert;
var refute = buster.refute;
var createServerFor = require("../test-helper").createServerFor;
var bSession = require("../../lib/buster-client/session");
var faye = require("faye");
var bayeuxEmitter = require("buster-bayeux-emitter");

buster.testCase("buster.session", {
    "createFromHttpResponse": {
        setUp: function () {
            this.response = buster.extend(buster.create(buster.eventEmitter), {
                headers: {
                    connection: "close",
                    "transfer-encoding": "chunked",
                    location: "/sessions/1"
                },
                statusCode: 201,
                setEncoding: this.spy()
            });

            this.respond = function (response) {
                response = response || JSON.stringify({
                    rootPath: "/sessions/1",
                    resourceContextPath: "/sessions/1/resources",
                    bayeuxClientPath: "/sessions/messaging",
                    id: 1,
                    clients: []
                });

                process.nextTick(function () {
                    this.response.emit("data", response);
                    this.response.emit("end");
                }.bind(this));

                return this.response;
            };

            this.stub(bayeuxEmitter, "create").returns({
                connect: this.stub().yields()
            });
        },

        "should resolve promise with session object": function (done) {
            var instance = { connect: this.stub().yields(instance) };
            this.stub(bSession, "create").returns(instance);

            bSession.createFromHttpResponse(this.response, {
                host: "localhost",
                port: 1111
            }).then(function (session) {
                assert.calledWith(response.setEncoding, "utf8");
                assert.equals(bSession.create.args[0][1], {
                    rootPath: "/sessions/1",
                    bayeuxClientPath: "/sessions/messaging",
                    resourceContextPath: "/sessions/1/resources",
                    id: 1,
                    host: "localhost",
                    port: 1111,
                    clients: []
                });

                assert.same(instance, session);
                done();
            });

            var response = this.respond();
        },

        "should reject promise with JSON parse error": function (done) {
            this.spy(bSession, "create");

            bSession.createFromHttpResponse(this.response).then(
                function () {},
                function (err, session) {
                    refute.defined(session);
                    refute.isNull(err);
                    refute.called(bSession.create);
                    done();
                });

            this.respond("{");
        },

        "should connect messaging client": function (done) {
            var opt = { host: "localhost", port: 1111 };

            bSession.createFromHttpResponse(this.response, opt).then(function (sess) {
                done(function () {
                    refute.isNull(sess.bayeuxClient);
                    assert.equals(sess.bayeuxClient.endpoint,
                                  "http://localhost:1111/sessions/messaging");
                });
            });

            this.respond();
        },

        "should not connect messaging client when no messaging path": function (done) {
            bSession.createFromHttpResponse(this.response).then(function (s) {
                assert.isNull(s.bayeuxClient);
                done();
            });

            var response = this.respond(JSON.stringify({
                rootPath: "/sessions/1"
            }));
        }
    },

    "create": {
        "should set rootPath, host, port and clients": function () {
            var session = bSession.create(null, {
                rootPath: "/sessions/0",
                host: "buster.local",
                port: 1110,
                clients: [{ id: "4d1eb0d1-8ffc-4e22-a163-e7a96cad73b3" }]
            });

            assert.match(session, {
                rootPath: "/sessions/0",
                host: "buster.local",
                port: 1110,
                clients: [{ id: "4d1eb0d1-8ffc-4e22-a163-e7a96cad73b3" }]
            });
        },

        "should default clients to empty array": function () {
            var session = bSession.create(null, {
                rootPath: "/sessions/0", host: "buster.local", port: 1110
            });

            assert.equals(session.clients, []);
        },

        "should use default host": function () {
            var session = bSession.create(null, {
                rootPath: "/sessions/0",
                port: 1110
            });

            assert.equals(session.host, "localhost");
        },

        "should use default port": function () {
            var session = bSession.create(null, { rootPath: "/sessions/0" });

            assert.equals(session.port, 1111);
        }
    },

    "close": {
        setUp: function (done) {
            this.requests = createServerFor(this, done);
        },

        tearDown: function () {
            this.server.close();
        },

        "should make DELETE request to session": function (done) {
            var session = bSession.create(null, {
                rootPath: "/sessions/1",
                host: "localhost",
                port: 7777
            });

            session.close().then(function () {
                assert.equals(this.requests.length, 1);
                assert.match(this.requests[0], {
                    method: "DELETE",
                    url: "/sessions/1"
                });

                done();
            }.bind(this));
        },

        "should use session properties in DELETE request": function (done) {
            var session = bSession.create(null, {
                rootPath: "/sessions/2",
                port: 7777
            });

            session.close().then(function () {
                assert.match(this.requests[0], { url: "/sessions/2" });
                done();
            }.bind(this));
        },

        "should reject promise with error on bad connection": function (done) {
            var session = bSession.create(null, {
                rootPath: "/sessions/2",
                host: "bogus"
            });

            session.close().then(function () {}, function (err) {
                refute.isNull(err);
                assert.match(err.message, /(Domain name not found)|(Could not contact DNS servers)/);
                done();
            }.bind(this));
        },

        "should reject promise if server responds with error": function (done) {
            this.responseCode = 500;

            var session = bSession.create(null, {
                rootPath: "/sessions/2",
                port: 7777
            });

            session.close().then(function () {}, function (err) {
                refute.isNull(err);
                assert.match(err.message, /500/);
                done();
            }.bind(this));
        },

        "should disconnect messaging client": function (done) {
            var session = bSession.create(null, {
                rootPath: "/sessions/2",
                port: 7777
            });

            var disconnect = this.spy();
            session.messagingClient = { disconnect: disconnect };

            session.close().then(function () {
                assert.calledOnce(disconnect);
                done();
            }.bind(this));
        },

        "should kill session": function (done) {
            var session = bSession.create(null, {
                rootPath: "/sessions/2",
                port: 7777
            });

            var http = require("http");
            this.spy(http, "request");

            session.close();

            process.nextTick(function () {
                assert.calledOnce(http.request);
                done();
            });
        }
    },

    "without messaging": {
        setUp: function () {
            this.session = bSession.create(null, {});
        },

        "on fails": function () {
            try {
                this.session.on("msg", function () {});
                throw new Error("Expected to fail");
            } catch (e) {
                assert.match(e.message, "Session has no messaging client");
            }
        },

        "emit should fail if session has no messaging client": function () {
            try {
                this.session.emit("msg");
                throw new Error("Expected to fail");
            } catch (e) {
                assert.match(e.message, "Session has no messaging client");
            }
        },

        "onMessage fails": function () {
            try {
                this.session.onMessage(function () {});
                throw new Error("Expected to fail");
            } catch (e) {
                assert.match(e.message, "Session has no messaging client");
            }
        }
    },

    "messaging": {
        setUp: function (done) {
            this.path = "/sessions/1/messages";
            this.url = "http://localhost:7777" + this.path;
            var mc = new faye.NodeAdapter({ mount: this.path });

            this.server = require("http").createServer(function (req, res) {
                res.writeHead(200);
                res.end();
            });

            mc.attach(this.server);
            this.server.listen(7777, done);
            this.bayeuxClient = new faye.Client(this.url);
            var self = this;

            this.connectedClient = function (then) {
                var session = bSession.create(self.bayeuxClient, {
                    port: 7777, id: 1, managed: self.managed
                });

                session.connect(function () { then(session); });
                return session;
            };
        },

        tearDown: function (done) {
            this.server.on("close", done);
            this.session.close().then(function () {
                this.server.close();
            }.bind(this));
        },

        "should send message with messaging client": function (done) {
            this.session = this.connectedClient(function (session) {
                session.on("/msg", function (msg) {
                    assert.equals(msg.data, 42);
                    done();
                });

                session.emit("/msg", 42);
            });
        },

        "should subscribe to any event": function (done) {
            this.session = this.connectedClient(function (session) {
                session.onMessage(function (msg) {
                    assert.equals(msg.data, 42);
                    assert.equals(msg.topic, "msg");
                    done();
                });

                session.emit("msg", 42);
            });
        },

        "publishes /session-owner for managed session": function (done) {
            var publish = this.stub(this.bayeuxClient, "publish");
            this.managed = true;

            this.session = this.connectedClient(function (session) {
                assert.calledOnceWith(publish, "/session-owner");
                done();
            });
        },

        "does not publish /session-owner for unmanaged session": function (done) {
            var publish = this.stub(this.bayeuxClient, "publish");
            this.managed = false;

            this.session = this.connectedClient(function (session) {
                refute.called(publish);
                done();
            });
        }
    }
});
