var http = require("http");
var path = require("path");
var responseBody = require("./util").responseBody;

var buster = require("buster-core");
var bPromise = require("buster-promise");
var bSession = require("./session");

function requestSessionCreation(client, options, callback) {
    var req = http.request(client.httpOptions("POST", "sessions"), function (res) {
        bSession.createFromHttpResponse(res, {
            host: client.host,
            port: client.port,
            managed: !!options.managed
        }).then(function (session) {
            callback(null, session);
        });
    });

    var resources = options.resourceSet.resources || [];

    for (var path in resources) {
        delete resources[path].cacheable;
    }

    req.on("error", callback);
    req.write(JSON.stringify(options));
    req.end();
}

function isCacheable(resource) {
    return resource.cacheable == null || !!resource.cacheable;
}

function isCached(path, resources, cache) {
    return cache[path] && cache[path].indexOf(resources[path].etag) >= 0;
}

module.exports = {
    cacheResources: true,

    create: function (port, host, path) {
        return buster.extend(Object.create(this), {
            port: port || 1111,
            host: host || "localhost",
            path: path || "/"
        });
    },

    getCachedResources: function () {
        var promise = bPromise.create();
        var self = this;

        if (this.cachedResources) {
            promise.resolve(this.cachedResources);
        } else {
            var opt = this.httpOptions("GET", "resources");

            var req = http.request(opt, function (res) {
                if (res.statusCode != 200) {
                    return promise.reject(new Error(
                        "Server responded to cache lookup with " +
                            res.statusCode + ", expected 200\n" +
                            "Is this server (" + opt.host + ":" + opt.port +
                            ") a buster-capture-server instance?"));
                }

                responseBody(res, function (body) {
                    try {
                        self.cachedResources = body && JSON.parse(body) || {};
                        promise.resolve(self.cachedResources);
                    } catch (e) {
                        promise.reject(new Error(
                            "Server responded to cache lookup with " +
                                "invalid response data. Is this server (" +
                                opt.host + ":" + opt.port +
                                ") a buster-capture-server instance?\n" +
                                "Original error was " + e.message));
                    }
                });
            }).on("error", function (err) {
                promise.reject(err);
            }).end();
        }

        return promise;
    },

    useCachedResources: function (resourceSet) {
        var promise = bPromise.create();
        var resources = resourceSet.resources;

        this.getCachedResources().then(function (cached) {
            for (var path in resources) {
                if (isCacheable(resources[path]) &&
                    isCached(path, resources, cached)) {
                    delete resources[path].content;
                }
            }

            promise.resolve(resourceSet);
        }, function (err) {
            promise.reject(err);
        });

        return promise;
    },

    createSession: function (configuration) {
        var promise = bPromise.create();

        prepareResources(this, configuration.resourceSet, function (err, set) {
            if (err) return promise.reject(err);
            var options = buster.extend({}, configuration, { resourceSet: set });
            requestSessionCreation(this, options, function (err, session) {
                if (err) return promise.reject(err);
                promise.resolve(session);
            });
        }.bind(this));

        return promise;
    },

    httpOptions: function (method, rpath) {
        return {
            method: method,
            host: this.host,
            port: this.port,
            path: path.join(this.path, rpath),
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };
    }
};

function prepareResources(client, resourceSet, callback) {
    resourceSet.getReadOnly(function (err, staticSet) {
        if (err) {
            err.message = "Bad session config: " + err.message;
            return callback(err);
        }

        var next = function (staticSet) { callback(null, staticSet); };

        if (client.cacheResources) {
            client.useCachedResources(staticSet).then(next, function (err) {
                callback(err);
            });
        } else {
            next(staticSet);
        }
    });
}
